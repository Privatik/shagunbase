Glide:::Что делает функция ".skipMemoryCache(true)":::Отказ от кэширования в памяти:::Отказ от кэширования в памяти--Кэширование в памяти--Изображение будет загружаться занаво, при исчезновении с поля зрения--Кэширует исходные и преобразованные данные
Glide:::Что делает следующее значение "DiskCacheStrategy.NONE":::Данные не сохраняется в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Что делает следующее значение "DiskCacheStrategy.SOURCE":::Исходные данные сохраняются в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Что делает следующее значение "DiskCacheStrategy.RESULT":::Сохраняет результат данных после преобразований в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Функция ".listener()" принимает значение:::new RequestListener<String, Bitmap>():::new RequestListener<String, Bitmap>()--new View.OnClickListener()--new RecyclerView.Adapter<VH>()--new ListenerView()
Glide:::Что делает функция ".asGif()":::Показывать анимированные GIF:::Показывать анимированные GIF--Запускает анимацию--Делает не анимированую картинку статичной--Метод который вызывается что бы создать анимацию
Glide:::Что делает функция ".dontAnimate()":::Отключает анимацию:::Отключает анимацию--Запускает анимацию--Делает не анимированую картинку статичной--Метод который вызывается что бы создать анимацию
Glide:::Что делает функция ".override(int,int)":::Изменить размер картинки:::Изменить размер картинки--Указать время выполнения анимации--Налаживает одно изображение поверх другого, по определеной площади--Стереть определеную площать картинки
Glide:::Что делает функция ".fitCenter()":::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область:::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область--Масштабирует изображение равномерно так, чтобы изображение заполняло данную область--Отменяет маштабирование--Устанавливает изобрадение по центру
Glide:::Что делает функция ".centerCrop()":::Масштабирует изображение равномерно так, чтобы изображение заполняло данную область:::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область--Масштабирует изображение равномерно так, чтобы изображение заполняло данную область--Отменяет маштабирование--Устанавливает изобрадение по центру
Glide:::Что делает функция ".placeholder(int resourceId)":::Что будет показано пока не загрузится и отобразится нужное изображение:::Что будет показано пока не загрузится и отобразится нужное изображение--Устанавливает картинку--Удаляет указаную картинку--Проверка на наличие изображения
Lifecycle:::Что делает функция ".getCurrentState()":::Возвращает сосотояние активности:::Возвращает состояние активности--проверяет наличие активности--Удаляет слушателя текущай активности--Обновляет состояние активности
Lifecycle:::Что делает аннотация "@OnLifecycleEvent":::Какое lifecycle-событие должено быть вызвано:::Какое lifecycle-событие должено быть вызвано--Запускать событие соответсвующее "OnStart"--Запускать событие соответсвующее "OnStop"--Данный метод будет вызываться автоматически
Lifecycle:::Что делает функция "getLifecycle().addObserver(LifecycleObserver)":::Подписывает LifecycleObserver:::Подписывает LifecycleObserver--Удаляет LifecycleObserver--Добавляет LifecycleObserver в список--Создает LifecycleObserver
Lifecycle:::Что делает функция "getLifecycle().addObserver(LifecycleObserver)":::Подписывает LifecycleObserver:::Подписывает LifecycleObserver--Удаляет LifecycleObserver--Добавляет LifecycleObserver в список--Создает LifecycleObserver
Lifecycle:::Зачем нужны класс "LifecycleRegistry" и интерфейс "LifecycleRegistryOwner":::Для самостоятельного обьявления кастомной Activity/Fragment, которые еще не поддерживают новый компонент:::Для самостоятельного обьявления кастомной Activity/Fragment, которые еще не поддерживают новый компонент--Замена класса Lifecycle--Для отслеживаний переходов между обьекта реализующими класс Lifecycle--Старая версия Lifecycle
LiveData:::Если Activity перейдет в статус DESTROYED:::LiveData автоматически отпишет от себя его observer:::LiveData автоматически отпишет от себя его observer--Ошибка--Ничего--Если observer не отписан, тогда Activty пересоздается
LiveData:::Если Activity в состоянии DESTROYED попробует подписаться:::Подписка не будет выполнена:::Подписка не будет выполнена--Activity пересоздается, подписка будет выполнена--Ничего--Ошибка
LiveData:::Если Activity в состоянии DESTROYED попробует подписаться:::Подписка не будет выполнена:::Подписка не будет выполнена--Activity пересоздается, подписка будет выполнена--Ничего--Ошибка
LiveData:::Как подписать активность на LiveData? с учетом жизненного цикла:::observe(LifecycleOwner, Observer<T>):::observe(LifecycleOwner, Observer<T>)--observeForever(Observer<T>)--Подписывается автоматически при создании активности--setValue(T)
LiveData:::Как отслеживать изменения в LiveData?:::С помощью интерфейса Observer<T>:::С помощью интерфейса Observer<T>--С помощью метода getValue()--С помощью специального класса MutableLiveData--Данная функия не требует реализации, так как все всроенно в систему
LiveData:::В чем главная разница между MutableLiveData и LiveData?:::MutableLiveData не абстрактный класс и методы setValue(T) и postValue(T) выведены в api:::MutableLiveData не абстрактный класс и методы setValue(T) и postValue(T) выведены в api--LiveData является наследником MutableLiveData--В MutableLiveData не методов setValue(T), getValue()--MutableLiveData интерфейс, а LiveData абстрактный класс
LiveData:::Зачем нужен класс MediatorLiveData?:::Дает возможность собирать данные из нескольких LiveData в один:::Дает возможность собирать данные из нескольких LiveData в один--Такого класса нет!--Наследник класса Activity и LiveData--Готовый холтер
LiveData:::Какие параметры принимает метод "MediatorLiveData.addSource(...)"?:::LiveData<T>, Observer<T>:::LiveData<T>--Observer<T>--MediatorLiveData()--LiveData<T>, Observer<T>
LiveData:::За что отвечает метод "onActive()"?:::Количество подписчиков изменилось с 0 на 1:::Количество подписчиков изменилось с 0 на 1--Количество подписчиков изменилось с 1 на 0--Вызывается при инициализации--Проверка на активность
LiveData:::Какие параметры принимает метод "Transformations.map(...)"?:::LiveData<T>, Function<T,P>:::LiveData<T>, Function<T,P>--Observer<T>--Function<T,P>--LiveData<T>, Observer<T>
LiveData:::В чем разница между "Transformations.switchMap(...)" и "Transformations.map(...)"?:::В switchMap принимает параметр Function<T,LiveData<P>>:::В switchMap принимает параметр Function<T,LiveData<P>>--В map принимает параметр Function<T,LiveData<P>>--switchMap не принимает обьект LiveData<T>--switchMap сразу может обращаться к Observer<P>
LiveData:::Что будет если вызвать "setValue(T)" не из UI потока?:::Ошибка:::Ошибка--Присвоит значение T--Вернет значение T--Ничего
LiveData:::Что делает функция "onInactive()"?:::Количество подписчиков изменилось с 1 на 0:::Количество подписчиков изменилось с 1 на 0--Количество подписчиков изменилось с 0 на 1--Вызывается при удалении Activity--Отписывается
ViewModule:::Что делает метод "ViewModelProviders.of(Activity).get(ViewModule)"?:::Запрашиваем у провайдера конкретную модель ViewModule:::Запрашиваем у провайдера конкретную модель ViewModule--Удаляет у провайдера конкретную модель ViewModule--Достает из массива у провайдера конкретную модель ViewModule--Создает у провайдера конкретную модель ViewModule
ViewModule:::Что делает метод "onCleared()"?:::Когда Activity окончательно закрывается, провайдер удаляет ViewModele:::Когда Activity окончательно закрывается, провайдер удаляет ViewModele--Удаление ViewModele--Очистка ViewModele--При повороте, ViewModule будут пересоздоваться
ViewModule:::Сколько ViewModule может хранить ViewModelProviders?:::Не ограниченное значение:::Не ограниченное значение--1-10--1--Этот класс не хранит ViewModule
ViewModule:::Для чего нужен ViewModule?:::Класс, позволяющий сохранять необходимые им объекты при повороте экрана:::Класс, позволяющий сохранять необходимые им объекты при повороте экрана--Очистка экрана от ненужной памяти--Является устаревшим классом и сейчас нигде не используется--Для корректного отображения элементом на View
ViewModule:::Разница AndroidViewModel и ViewModule?:::AndroidViewModel принимает конструктор Application:::AndroidViewModel принимает конструктор Application--AndroidViewModel принимает конструктор Context--AndroidViewModel берет меньше памяти при ассинхроной работе--AndroidViewModel берет больше памяти при ассинхроной работе
ViewModule:::Зачем нуден класс ViewModelProvider.NewInstanceFactory?:::Для передачи в модель какие-либо данные при создании:::Для передачи в модель какие-либо данные при создании--ViewModule который не умерат при закрытия приложения--Для работы с несколькими ViewModule--Класс холтер
Room:::Какие обязательные(ый) аннотации(ия) должны(а) быть в классе, что бы сделать из него таблицу?:::@Entity и @PrimaryKey:::@Entity и @PrimaryKey--@Entity--@Dao и @PrimaryKey--@Database
Room:::Зачем используется интерфейс с аннотацией Dao?:::Для писывать методы для работы с базой данных:::Для писывать методы для работы с базой данных--Класс который будет от него инициализирован будем базой--Для обьеденения двух баз--Это сама база данных
Room:::Какая аннотация служит для добавления обьектов в базу данных?:::@Insert:::@Insert--@Update--@Delete--@Query
Room:::Какой абстрактынй класс помечается аннотацией @Database?:::Основной класс по работе с базой данных:::Основной класс по работе с базой данных--Сама база данных--Этой аннотацией помечается метод, с помощью которого делаться SQL запросы--Класс для хранения обьектов
Room:::Для чего нужна аннотация @ColumnInfo?:::Указать свое имя для переменой:::Указать свое имя для переменой--Не сохранять переменую в таблицу--Преобразовать ее в другой тип--Сделать переменую индивидуальной в каждой таблице
Room:::Какая аннотация служит для получения информации из базы данных?:::@Query:::@Insert--@Update--@Delete--@Query
Room:::За что отвечает слудующая аннотация @Entity(foreignKeys = @ForeignKey(entity = Employee.class, parentColumns = "id", childColumns = "child_id"))?:::Внешний ключ:::Внешний ключ--Внутрений ключ--Составной ключ--Интегрированый ключ
Room:::Зачем нужен внешний ключ?:::Позволяют связывать таблицы между собой:::Позволяют связывать таблицы между собой--Позволяет связаться с LiveDate--Такого понятия нет--Позволяет связаться с Activity
Room:::Что делает данная аннотация @PrimaryKey(autoGenerate = true)?:::База данных сама будет генерировать значение, если вы его не укажете:::База данных сама будет генерировать значение, если вы его не укажете--В случаи ошибки считывания база сама создаст значение--Подобрать нужный тип автоматически--Не сохранять переменую, так как она не нужна, и будет создаваться автоматически во время вызова
Room:::Что делает данная аннотация @ColumnInfo(index = true)?:::База будет следить, чтобы в этой таблице не было повторений:::База будет следить, чтобы в этой таблице не было повторений--Переменная является индексом--Переменная будет ключем--Установить переменой значение по дефолту
Room:::Что делает данная аннотация @Embedded?:::Взять поля из переменной(наш класс) и считать их полями таблицы:::Взять поля из переменной(наш класс) и считать их полями таблицы--Не включать переменную в таблицу--Переменная будет ключем--В случаи ошибки ее не сохранять
Room:::Что делает данная аннотация @Ignore?:::Поле не должно записываться в базу:::Поле не должно записываться в базу--Игнорировать вызов данного метода--Во время вызова генерировать исключение--Не отображать переменную при вызове
Room:::Что делает данная аннотация @Insert(onConflict = OnConflictStrategy.REPLACE)?:::В случаи совпадений старая запись будет заменена новой:::В случаи совпадений старая запись будет заменена новой--База содержит только один желемент и он постоянно перезаписывается--Не записывать элемент если его ещё нет в таблице--Дает ограничение на запись
Room:::Что делает данная аннотация @Insert(onConflict = OnConflictStrategy.IGNORE)?:::В случаи совпадений старая запись не будет заменена новой:::В случаи совпадений старая запись не будет заменена новой--Игнорировать занисение в таблицу--Ограничить таблицу на запись параметром который выставляется заранее--Какие-то записи не сохранять
Room:::Что вернет данный метод \n @Delete \nint delete(List<Employee> employee)?:::Количество удаленных записей:::Количество удаленных записей--ID первой удаленной записи--ID последней удаленной записи--возращает в зависимости от успеха удаления число
Room:::Что делает данная аннотация @Transaction?:::Позволяет выполнять несколько методов в рамках одной транзакции:::Позволяет выполнять несколько методов в рамках одной транзакции--Производит транзакцию между двумя классами--Быстрая и не сложная в применении БД--Происходит транзакция обмена данных между двумя объектами
Room:::Возможна ли такая запись \n @Query("SELECT * FROM employee") \nLiveData<List<Employee>> getAll()?:::Да:::Да--Нет, код вызовет ошибку--Да, но чего-то не хватает...--С LiveData такие операции не возможны
Room:::Что такое Subsets?:::Технология позволяющая получить определенные поля и базы данных:::Технология позволяющая получить определенные поля и базы данных--Подгруппа--Позволяется соединять две таблицы--Такого понятия нет
Room:::Какие типы принимает аннтотация @Relation?:::List или Set:::List или Set--Set или Map--List или миссивы--Map
Room:::Зачем используется данная аннотация @Relation(parentColumn = "id", entityColumn = "department_id", entity = Employee.class)?:::Чтобы вытянуть из класса Employee часть необходимых переменных:::Чтобы вытянуть из класса Employee часть необходимых переменных--Что полностью сзязать две таблиц одна из которых Employer--Удаление из всей таблиц особых переменных--В данной аннтоции ошибка
Room:::Зачем используется сочетание Relation + Transaction?:::Запросы в одной транзакции, чтобы получить корректные данные:::Запросы в одной транзакции, чтобы получить корректные данные--Такой комбинации нет--Для получение двух разных ответов--Что бы отслеживать какая информация поступает
Room:::Что делает аннотация @TypeConverter?:::Для сохранениея в базу полей которые не являются примитивами:::Для сохранениея в базу полей которые не являются примитивами--Для перевода при сохранении в другой тип(Int - Double)--Узнать тип данных в таблице--Переформатирование таблицы
Room:::Что делает данный метод \n @Query("SELECT * FROM employee WHERE birthday = :birthday") \n Employee getByDate(@TypeConverters({DateConverter.class}) Date birthday)?:::Преобразует birthday к не видемому для нас примитиву и вернет обьект класса Employee:::Преобразует birthday к не видемому для нас примитиву и вернет обьект класса Employee--Не генерирует исключения при ошибке. просто пропускает--Найдет нужную нам дату--Ничего такой комбинации нет
SQL:::Если вы меняете структуру базы данных...:::необходимо поднимать версию базы данных:::необходимо поднимать версию базы данных--такое не возможно--необходимо дать им специлаьную аннтоацию--Удалить всю базу и создать ее заново
Room:::Зачем нужен объект Migration?:::Сделать миграцию между версиями баз данных:::Сделать миграцию между версиями баз данных--Сделать миграцию в другую базу--Сделаеть миграцию из другой базы--Для получение внешних ключей
Room:::Какой метод нужно вызвать у Room.databaseBuilder().. что бы указать миграцию версий?:::.addMigrations(AppDatabase.MIGRATION_1_2):::.addMigrations(AppDatabase.MIGRATION_1_2)--.putMigrations(AppDatabase.MIGRATION_1_2)--.cutMigrations(AppDatabase.MIGRATION_1_2)--.foundMigrations()
Service:::Когда вызывается метод .onStartCommand ?:::Когда сервис запущен методом startService:::Когда сервис запущен методом startService--При любом запуске сервиса--На в сервис поступает информация--При любом обращении к сервису
Service:::Что делает метод stopSelf()?:::Уничтожает сервис изнутри:::Уничтожает сервис изнутри--Преостонавливает сервис--Останавливает все сервисы за раз--Такого метода нет
Service:::Какая роль у переменной startId?:::Счетчик вызовов startService:::Счетчик вызовов startService--Хронит количество запущенных сервисов на телефоне--Такой переменой нет--Имя сервиса
Service:::Что делает метод stopSelf(startId):::Уничтожает сервис под номером startId:::Уничтожает сервис под номером startId--Сервис на делает паузу на startId миллисекунд--Освобождает необходимое число памяти--Такого мотода нет
Service:::В чем разницу между stopSelfResult(startId) и stopSelf(startId?:::stopSelfResult(startId) возвращает boolean если после вызова этой функции сервис был остановлен:::stopSelfResult(startId) возвращает boolean если после вызова этой функции сервис был остановлен--stopSelfResult(startId) возращает результат работы сервиса--stopSelfResult(startId) не уничтожает сервис, а возращает промежуточный результат его работы--stopSelfResult(startId) одно и тоже просто одно использовалось в более раней версии
Service:::Что делает флаг onStartCommand.START_NOT_STICKY?:::Сервис не будет перезапущен после того, как был убит системой:::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId)--Сервис будет перезапущен после того, как был убит системой--Сервис не будет перезапущен после того, как был убит системой--Такого флага нет
Service:::Что делает флаг onStartCommand.START_STICKY?:::Сервис будет перезапущен после того, как был убит системой:::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId)--Сервис будет перезапущен после того, как был убит системой--Сервис не будет перезапущен после того, как был убит системой--Такого флага нет
Service:::Что делает флаг onStartCommand.START_REDELIVER_INTENT?:::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId):::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId)--Сервис будет перезапущен после того, как был убит системой--Сервис не будет перезапущен после того, как был убит системой--Такого флага нет
Service:::Что делает флаг START_FLAG_REDELIVERY?:::Мы получали такой вызов, но в прошлый раз:::Мы получали такой вызов, но в прошлый раз--Сервис удален системой--Сервис был вызван впервый раз--Ошибка при прикрощении работы сервиса
Service:::Что делает метод PendingIntent.send()?:::Отправляет информацию из сервиса в активити:::Отправляет информацию из сервиса в активити--Просил информацию из активити--Отправляет почту--Нужен для запроса на разрешение использовать сервис в фоновом режиме
Dagger2:::Для чего нужна аннотация @Provides?:::Указывает, что метод является поставщиком объекта:::Указывает, что метод является поставщиком объекта--Указывает что метод является провайдером--Указывает что переменная является провайдером--Класс является компонентом
Dagger2:::Для чего нужна аннотация @Component?:::Для генерации класса DaggerAppComponent:::Для генерации класса DaggerAppComponent--Класс для хранения модулей--Класс для вызова модулей--Переменная поиска элементов в Dagger
