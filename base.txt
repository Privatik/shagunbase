Glide:::Что делает функция ".skipMemoryCache(true)":::Отказ от кэширования в памяти:::Отказ от кэширования в памяти--Кэширование в памяти--Изображение будет загружаться занаво, при исчезновении с поля зрения--Кэширует исходные и преобразованные данные
Glide:::Что делает следующее значение "DiskCacheStrategy.NONE":::Данные не сохраняется в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Что делает следующее значение "DiskCacheStrategy.SOURCE":::Исходные данные сохраняются в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Что делает следующее значение "DiskCacheStrategy.RESULT":::Сохраняет результат данных после преобразований в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Функция ".listener()" принимает значение:::new RequestListener<String, Bitmap>():::new RequestListener<String, Bitmap>()--new View.OnClickListener()--new RecyclerView.Adapter<VH>()--new ListenerView()
Glide:::Что делает функция ".asGif()":::Показывать анимированные GIF:::Показывать анимированные GIF--Запускает анимацию--Делает не анимированую картинку статичной--Метод который вызывается что бы создать анимацию
Glide:::Что делает функция ".dontAnimate()":::Отключает анимацию:::Отключает анимацию--Запускает анимацию--Делает не анимированую картинку статичной--Метод который вызывается что бы создать анимацию
Glide:::Что делает функция ".override(int,int)":::Изменить размер картинки:::Изменить размер картинки--Указать время выполнения анимации--Налаживает одно изображение поверх другого, по определеной площади--Стереть определеную площать картинки
Glide:::Что делает функция ".fitCenter()":::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область:::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область--Масштабирует изображение равномерно так, чтобы изображение заполняло данную область--Отменяет маштабирование--Устанавливает изобрадение по центру
Glide:::Что делает функция ".centerCrop()":::Масштабирует изображение равномерно так, чтобы изображение заполняло данную область:::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область--Масштабирует изображение равномерно так, чтобы изображение заполняло данную область--Отменяет маштабирование--Устанавливает изобрадение по центру
Glide:::Что делает функция ".placeholder(int resourceId)":::Что будет показано пока не загрузится и отобразится нужное изображение:::Что будет показано пока не загрузится и отобразится нужное изображение--Устанавливает картинку--Удаляет указаную картинку--Проверка на наличие изображения
Lifecycle:::Что делает функция ".getCurrentState()":::Возвращает сосотояние активности:::Возвращает состояние активности--проверяет наличие активности--Удаляет слушателя текущай активности--Обновляет состояние активности
Lifecycle:::Что делает аннотация "@OnLifecycleEvent":::Какое lifecycle-событие должено быть вызвано:::Какое lifecycle-событие должено быть вызвано--Запускать событие соответсвующее "OnStart"--Запускать событие соответсвующее "OnStop"--Данный метод будет вызываться автоматически
Lifecycle:::Что делает функция "getLifecycle().addObserver(LifecycleObserver)":::Подписывает LifecycleObserver:::Подписывает LifecycleObserver--Удаляет LifecycleObserver--Добавляет LifecycleObserver в список--Создает LifecycleObserver
Lifecycle:::Что делает функция "getLifecycle().addObserver(LifecycleObserver)":::Подписывает LifecycleObserver:::Подписывает LifecycleObserver--Удаляет LifecycleObserver--Добавляет LifecycleObserver в список--Создает LifecycleObserver
Lifecycle:::Зачем нужны класс "LifecycleRegistry" и интерфейс "LifecycleRegistryOwner":::Для самостоятельного обьявления кастомной Activity/Fragment, которые еще не поддерживают новый компонент:::Для самостоятельного обьявления кастомной Activity/Fragment, которые еще не поддерживают новый компонент--Замена класса Lifecycle--Для отслеживаний переходов между обьекта реализующими класс Lifecycle--Старая версия Lifecycle
LiveData:::Если Activity перейдет в статус DESTROYED:::LiveData автоматически отпишет от себя его observer:::LiveData автоматически отпишет от себя его observer--Ошибка--Ничего--Если observer не отписан, тогда Activty пересоздается
LiveData:::Если Activity в состоянии DESTROYED попробует подписаться:::Подписка не будет выполнена:::Подписка не будет выполнена--Activity пересоздается, подписка будет выполнена--Ничего--Ошибка
LiveData:::Если Activity в состоянии DESTROYED попробует подписаться:::Подписка не будет выполнена:::Подписка не будет выполнена--Activity пересоздается, подписка будет выполнена--Ничего--Ошибка
LiveData:::Как подписать активность на LiveData? с учетом жизненного цикла:::observe(LifecycleOwner, Observer<T>):::observe(LifecycleOwner, Observer<T>)--observeForever(Observer<T>)--Подписывается автоматически при создании активности--setValue(T)
LiveData:::Как отслеживать изменения в LiveData?:::С помощью интерфейса Observer<T>:::С помощью интерфейса Observer<T>--С помощью метода getValue()--С помощью специального класса MutableLiveData--Данная функия не требует реализации, так как все всроенно в систему
LiveData:::В чем главная разница между MutableLiveData и LiveData?:::MutableLiveData не абстрактный класс и методы setValue(T) и postValue(T) выведены в api:::MutableLiveData не абстрактный класс и методы setValue(T) и postValue(T) выведены в api--LiveData является наследником MutableLiveData--В MutableLiveData не методов setValue(T), getValue()--MutableLiveData интерфейс, а LiveData абстрактный класс
LiveData:::Зачем нужен класс MediatorLiveData?:::Дает возможность собирать данные из нескольких LiveData в один:::Дает возможность собирать данные из нескольких LiveData в один--Такого класса нет!--Наследник класса Activity и LiveData--Готовый холтер
LiveData:::Какие параметры принимает метод "MediatorLiveData.addSource(...)"?:::LiveData<T>, Observer<T>:::LiveData<T>--Observer<T>--MediatorLiveData()--LiveData<T>, Observer<T>
LiveData:::За что отвечает метод "onActive()"?:::Количество подписчиков изменилось с 0 на 1:::Количество подписчиков изменилось с 0 на 1--Количество подписчиков изменилось с 1 на 0--Вызывается при инициализации--Проверка на активность
LiveData:::Какие параметры принимает метод "Transformations.map(...)"?:::LiveData<T>, Function<T,P>:::LiveData<T>, Function<T,P>--Observer<T>--Function<T,P>--LiveData<T>, Observer<T>
LiveData:::В чем разница между "Transformations.switchMap(...)" и "Transformations.map(...)"?:::В switchMap принимает параметр Function<T,LiveData<P>>:::В switchMap принимает параметр Function<T,LiveData<P>>--В map принимает параметр Function<T,LiveData<P>>--switchMap не принимает обьект LiveData<T>--switchMap сразу может обращаться к Observer<P>
LiveData:::Что будет если вызвать "setValue(T)" не из UI потока?:::Ошибка:::Ошибка--Присвоит значение T--Вернет значение T--Ничего
LiveData:::Что делает функция "onInactive()"?:::Количество подписчиков изменилось с 1 на 0:::Количество подписчиков изменилось с 1 на 0--Количество подписчиков изменилось с 0 на 1--Вызывается при удалении Activity--Отписывается
ViewModule:::Что делает метод "ViewModelProviders.of(Activity).get(ViewModule)"?:::Запрашиваем у провайдера конкретную модель ViewModule:::Запрашиваем у провайдера конкретную модель ViewModule--Удаляет у провайдера конкретную модель ViewModule--Достает из массива у провайдера конкретную модель ViewModule--Создает у провайдера конкретную модель ViewModule
ViewModule:::Что делает метод "onCleared()"?:::Когда Activity окончательно закрывается, провайдер удаляет ViewModele:::Когда Activity окончательно закрывается, провайдер удаляет ViewModele--Удаление ViewModele--Очистка ViewModele--При повороте, ViewModule будут пересоздоваться
ViewModule:::Сколько ViewModule может хранить ViewModelProviders?:::Не ограниченное значение:::Не ограниченное значение--1-10--1--Этот класс не хранит ViewModule
ViewModule:::Для чего нужен ViewModule?:::Класс, позволяющий сохранять необходимые им объекты при повороте экрана:::Класс, позволяющий сохранять необходимые им объекты при повороте экрана--Очистка экрана от ненужной памяти--Является устаревшим классом и сейчас нигде не используется--Для корректного отображения элементом на View
ViewModule:::Разница AndroidViewModel и ViewModule?:::AndroidViewModel принимает конструктор Application:::AndroidViewModel принимает конструктор Application--AndroidViewModel принимает конструктор Context--AndroidViewModel берет меньше памяти при ассинхроной работе--AndroidViewModel берет больше памяти при ассинхроной работе
ViewModule:::Зачем нуден класс ViewModelProvider.NewInstanceFactory?:::Для передачи в модель какие-либо данные при создании:::Для передачи в модель какие-либо данные при создании--ViewModule который не умерат при закрытия приложения--Для работы с несколькими ViewModule--Класс холтер
Room:::Какие обязательные(ый) аннотации(ия) должны(а) быть в классе, что бы сделать из него таблицу?:::@Entity и @PrimaryKey:::@Entity и @PrimaryKey--@Entity--@Dao и @PrimaryKey--@Database
Room:::Зачем используется интерфейс с аннотацией Dao?:::Для писывать методы для работы с базой данных:::Для писывать методы для работы с базой данных--Класс который будет от него инициализирован будем базой--Для обьеденения двух баз--Это сама база данных
Room:::Какая аннотация служит для добавления обьектов в базу данных?:::@Insert:::@Insert--@Update--@Delete--@Query
Room:::Какой абстрактынй класс помечается аннотацией @Database?:::Основной класс по работе с базой данных:::Основной класс по работе с базой данных--Сама база данных--Этой аннотацией помечается метод, с помощью которого делаться SQL запросы--Класс для хранения обьектов
Room:::Для чего нужна аннотация @ColumnInfo?:::Указать свое имя для переменой:::Указать свое имя для переменой--Не сохранять переменую в таблицу--Преобразовать ее в другой тип--Сделать переменую индивидуальной в каждой таблице
Room:::Какая аннотация служит для получения информации из базы данных?:::@Query:::@Insert--@Update--@Delete--@Query
Room:::За что отвечает слудующая аннотация @Entity(foreignKeys = @ForeignKey(entity = Employee.class, parentColumns = "id", childColumns = "employee_id"))?:::Внешний ключ:::Внешний ключ--Внутрений ключ--Составной ключ--Интегрированый ключ
Room:::Зачем нужен внешний ключ?:::Позволяют связывать таблицы между собой:::Позволяют связывать таблицы между собой--Позволяет связаться с LiveDate--Такого понятия нет--Позволяет связаться с Activity
Room:::Что делает данная аннотация @PrimaryKey(autoGenerate = true)?:::База данных сама будет генерировать значение, если вы его не укажете:::База данных сама будет генерировать значение, если вы его не укажете--В случаи ошибки считывания база сама создаст значение--Подобрать нужный тип автоматически--Не сохранять переменую, так как она не нужна, и будет создаваться автоматически во время вызова
Room:::Что делает данная аннотация @ColumnInfo(index = true)?:::База будет следить, чтобы в этой таблице не было повторений:::База будет следить, чтобы в этой таблице не было повторений--Переменная является индексом--Переменная будет ключем--Установить переменой значение по дефолту
Room:::Что делает данная аннотация @Embedded?:::Взять поля из переменной(наш класс) и считать их полями таблицы:::Взять поля из переменной(наш класс) и считать их полями таблицы--Не включать переменную в таблицу--Переменная будет ключем--В случаи ошибки ее не сохранять
Room:::Что делает данная аннотация @Ignore?:::Поле не должно записываться в базу:::Поле не должно записываться в базу--Игнорировать вызов данного метода--Во время вызова генерировать исключение--Не отображать переменную при вызове
Room:::Что делает данная аннотация @Insert(onConflict = OnConflictStrategy.REPLACE)?:::В случаи совпадений старая запись будет заменена новой:::В случаи совпадений старая запись будет заменена новой--База содержит только один желемент и он постоянно перезаписывается--Не записывать элемент если его ещё нет в таблице--Дает ограничение на запись
Room:::Что делает данная аннотация @Insert(onConflict = OnConflictStrategy.IGNORE)?:::В случаи совпадений старая запись не будет заменена новой:::В случаи совпадений старая запись не будет заменена новой--Игнорировать занисение в таблицу--Ограничить таблицу на запись параметром который выставляется заранее--Какие-то записи не сохранять
