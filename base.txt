Glide:::Что делает функция ".skipMemoryCache(true)":::Отказ от кэширования в памяти:::Отказ от кэширования в памяти--Кэширование в памяти--Изображение будет загружаться занаво, при исчезновении с поля зрения--Кэширует исходные и преобразованные данные
Glide:::Что делает следующее значение "DiskCacheStrategy.NONE":::Данные не сохраняется в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Что делает следующее значение "DiskCacheStrategy.SOURCE":::Исходные данные сохраняются в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Что делает следующее значение "DiskCacheStrategy.RESULT":::Сохраняет результат данных после преобразований в кэше:::Данные не сохраняется в кэше--Сохраняет результат данных после преобразований в кэше--Кэширует исходные и преобразованные данные--Исходные данные сохраняются в кэше
Glide:::Функция ".listener()" принимает значение:::new RequestListener<String, Bitmap>():::new RequestListener<String, Bitmap>()--new View.OnClickListener()--new RecyclerView.Adapter<VH>()--new ListenerView()
Glide:::Что делает функция ".asGif()":::Показывать анимированные GIF:::Показывать анимированные GIF--Запускает анимацию--Делает не анимированую картинку статичной--Метод который вызывается что бы создать анимацию
Glide:::Что делает функция ".dontAnimate()":::Отключает анимацию:::Отключает анимацию--Запускает анимацию--Делает не анимированую картинку статичной--Метод который вызывается что бы создать анимацию
Glide:::Что делает функция ".override(int,int)":::Изменить размер картинки:::Изменить размер картинки--Указать время выполнения анимации--Налаживает одно изображение поверх другого, по определеной площади--Стереть определеную площать картинки
Glide:::Что делает функция ".fitCenter()":::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область:::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область--Масштабирует изображение равномерно так, чтобы изображение заполняло данную область--Отменяет маштабирование--Устанавливает изобрадение по центру
Glide:::Что делает функция ".centerCrop()":::Масштабирует изображение равномерно так, чтобы изображение заполняло данную область:::Масштабирует изображение равномерно так, чтобы изображение вместилось в данную область--Масштабирует изображение равномерно так, чтобы изображение заполняло данную область--Отменяет маштабирование--Устанавливает изобрадение по центру
Glide:::Что делает функция ".placeholder(int resourceId)":::Что будет показано пока не загрузится и отобразится нужное изображение:::Что будет показано пока не загрузится и отобразится нужное изображение--Устанавливает картинку--Удаляет указаную картинку--Проверка на наличие изображения
Lifecycle:::Что делает функция ".getCurrentState()":::Возвращает состояние активности:::Возвращает состояние активности--Проверяет наличие активности--Удаляет слушателя текущай активности--Обновляет состояние активности
Lifecycle:::Что делает аннотация "@OnLifecycleEvent":::Какое lifecycle-событие должено быть вызвано:::Какое lifecycle-событие должено быть вызвано--Запускать событие соответсвующее "OnStart"--Запускать событие соответсвующее "OnStop"--Данный метод будет вызываться автоматически
Lifecycle:::Что делает функция "getLifecycle().addObserver(LifecycleObserver)":::Подписывает LifecycleObserver:::Подписывает LifecycleObserver--Удаляет LifecycleObserver--Добавляет LifecycleObserver в список--Создает LifecycleObserver
Lifecycle:::Что делает функция "getLifecycle().addObserver(LifecycleObserver)":::Подписывает LifecycleObserver:::Подписывает LifecycleObserver--Удаляет LifecycleObserver--Добавляет LifecycleObserver в список--Создает LifecycleObserver
Lifecycle:::Зачем нужны класс "LifecycleRegistry" и интерфейс "LifecycleRegistryOwner":::Для самостоятельного обьявления кастомной Activity/Fragment, которые еще не поддерживают новый компонент:::Для самостоятельного обьявления кастомной Activity/Fragment, которые еще не поддерживают новый компонент--Замена класса Lifecycle--Для отслеживаний переходов между обьекта реализующими класс Lifecycle--Старая версия Lifecycle
LiveData:::Если Activity перейдет в статус DESTROYED:::LiveData автоматически отпишет от себя его observer:::LiveData автоматически отпишет от себя его observer--Ошибка--Ничего--Если observer не отписан, тогда Activty пересоздается
LiveData:::Если Activity в состоянии DESTROYED попробует подписаться:::Подписка не будет выполнена:::Подписка не будет выполнена--Activity пересоздается, подписка будет выполнена--Ничего--Ошибка
LiveData:::Если Activity в состоянии DESTROYED попробует подписаться:::Подписка не будет выполнена:::Подписка не будет выполнена--Activity пересоздается, подписка будет выполнена--Ничего--Ошибка
LiveData:::Как подписать активность на LiveData? с учетом жизненного цикла:::observe(LifecycleOwner, Observer<T>):::observe(LifecycleOwner, Observer<T>)--observeForever(Observer<T>)--Подписывается автоматически при создании активности--setValue(T)
LiveData:::Как отслеживать изменения в LiveData?:::С помощью интерфейса Observer<T>:::С помощью интерфейса Observer<T>--С помощью метода getValue()--С помощью специального класса MutableLiveData--Данная функия не требует реализации, так как все всроенно в систему
LiveData:::В чем главная разница между MutableLiveData и LiveData?:::MutableLiveData не абстрактный класс и методы setValue(T) и postValue(T) выведены в api:::MutableLiveData не абстрактный класс и методы setValue(T) и postValue(T) выведены в api--LiveData является наследником MutableLiveData--В MutableLiveData не методов setValue(T), getValue()--MutableLiveData интерфейс, а LiveData абстрактный класс
LiveData:::Зачем нужен класс MediatorLiveData?:::Дает возможность собирать данные из нескольких LiveData в один:::Дает возможность собирать данные из нескольких LiveData в один--Такого класса нет!--Наследник класса Activity и LiveData--Готовый холтер
LiveData:::Какие параметры принимает метод "MediatorLiveData.addSource(...)"?:::LiveData<T>, Observer<T>:::LiveData<T>--Observer<T>--MediatorLiveData()--LiveData<T>, Observer<T>
LiveData:::За что отвечает метод "onActive()"?:::Количество подписчиков изменилось с 0 на 1:::Количество подписчиков изменилось с 0 на 1--Количество подписчиков изменилось с 1 на 0--Вызывается при инициализации--Проверка на активность
LiveData:::Какие параметры принимает метод "Transformations.map(...)"?:::LiveData<T>, Function<T,P>:::LiveData<T>, Function<T,P>--Observer<T>--Function<T,P>--LiveData<T>, Observer<T>
LiveData:::В чем разница между "Transformations.switchMap(...)" и "Transformations.map(...)"?:::В switchMap принимает параметр Function<T,LiveData<P>>:::В switchMap принимает параметр Function<T,LiveData<P>>--В map принимает параметр Function<T,LiveData<P>>--switchMap не принимает обьект LiveData<T>--switchMap сразу может обращаться к Observer<P>
LiveData:::Что будет если вызвать "setValue(T)" не из UI потока?:::Ошибка:::Ошибка--Присвоит значение T--Вернет значение T--Ничего
LiveData:::Что делает функция "onInactive()"?:::Количество подписчиков изменилось с 1 на 0:::Количество подписчиков изменилось с 1 на 0--Количество подписчиков изменилось с 0 на 1--Вызывается при удалении Activity--Отписывается
ViewModule:::Что делает метод "ViewModelProviders.of(Activity).get(ViewModule)"?:::Запрашиваем у провайдера конкретную модель ViewModule:::Запрашиваем у провайдера конкретную модель ViewModule--Удаляет у провайдера конкретную модель ViewModule--Достает из массива у провайдера конкретную модель ViewModule--Создает у провайдера конкретную модель ViewModule
ViewModule:::Что делает метод "onCleared()"?:::Когда Activity окончательно закрывается, провайдер удаляет ViewModele:::Когда Activity окончательно закрывается, провайдер удаляет ViewModele--Удаление ViewModele--Очистка ViewModele--При повороте, ViewModule будут пересоздоваться
ViewModule:::Сколько ViewModule может хранить ViewModelProviders?:::Не ограниченное значение:::Не ограниченное значение--1-10--1--Этот класс не хранит ViewModule
ViewModule:::Для чего нужен ViewModule?:::Класс, позволяющий сохранять необходимые им объекты при повороте экрана:::Класс, позволяющий сохранять необходимые им объекты при повороте экрана--Очистка экрана от ненужной памяти--Является устаревшим классом и сейчас нигде не используется--Для корректного отображения элементом на View
ViewModule:::Разница AndroidViewModel и ViewModule?:::AndroidViewModel принимает конструктор Application:::AndroidViewModel принимает конструктор Application--AndroidViewModel принимает конструктор Context--AndroidViewModel берет меньше памяти при ассинхроной работе--AndroidViewModel берет больше памяти при ассинхроной работе
ViewModule:::Зачем нуден класс ViewModelProvider.NewInstanceFactory?:::Для передачи в модель какие-либо данные при создании:::Для передачи в модель какие-либо данные при создании--ViewModule который не умерат при закрытия приложения--Для работы с несколькими ViewModule--Класс холтер
Room:::Какие обязательные(ый) аннотации(ия) должны(а) быть в классе, что бы сделать из него таблицу?:::@Entity и @PrimaryKey:::@Entity и @PrimaryKey--@Entity--@Dao и @PrimaryKey--@Database
Room:::Зачем используется интерфейс с аннотацией Dao?:::Для писывать методы для работы с базой данных:::Для писывать методы для работы с базой данных--Класс который будет от него инициализирован будем базой--Для обьеденения двух баз--Это сама база данных
Room:::Какая аннотация служит для добавления обьектов в базу данных?:::@Insert:::@Insert--@Update--@Delete--@Query
Room:::Какой абстрактынй класс помечается аннотацией @Database?:::Основной класс по работе с базой данных:::Основной класс по работе с базой данных--Сама база данных--Этой аннотацией помечается метод, с помощью которого делаться SQL запросы--Класс для хранения обьектов
Room:::Для чего нужна аннотация @ColumnInfo?:::Указать свое имя для переменой:::Указать свое имя для переменой--Не сохранять переменую в таблицу--Преобразовать ее в другой тип--Сделать переменую индивидуальной в каждой таблице
Room:::Какая аннотация служит для получения информации из базы данных?:::@Query:::@Insert--@Update--@Delete--@Query
Room:::За что отвечает слудующая аннотация @Entity(foreignKeys = @ForeignKey(entity = Employee.class, parentColumns = "id", childColumns = "child_id"))?:::Внешний ключ:::Внешний ключ--Внутрений ключ--Составной ключ--Интегрированый ключ
Room:::Зачем нужен внешний ключ?:::Позволяют связывать таблицы между собой:::Позволяют связывать таблицы между собой--Позволяет связаться с LiveDate--Такого понятия нет--Позволяет связаться с Activity
Room:::Что делает данная аннотация @PrimaryKey(autoGenerate = true)?:::База данных сама будет генерировать значение, если вы его не укажете:::База данных сама будет генерировать значение, если вы его не укажете--В случаи ошибки считывания база сама создаст значение--Подобрать нужный тип автоматически--Не сохранять переменую, так как она не нужна, и будет создаваться автоматически во время вызова
Room:::Что делает данная аннотация @ColumnInfo(index = true)?:::База будет следить, чтобы в этой таблице не было повторений:::База будет следить, чтобы в этой таблице не было повторений--Переменная является индексом--Переменная будет ключем--Установить переменой значение по дефолту
Room:::Что делает данная аннотация @Embedded?:::Взять поля из переменной(наш класс) и считать их полями таблицы:::Взять поля из переменной(наш класс) и считать их полями таблицы--Не включать переменную в таблицу--Переменная будет ключем--В случаи ошибки ее не сохранять
Room:::Что делает данная аннотация @Ignore?:::Поле не должно записываться в базу:::Поле не должно записываться в базу--Игнорировать вызов данного метода--Во время вызова генерировать исключение--Не отображать переменную при вызове
Room:::Что делает данная аннотация @Insert(onConflict = OnConflictStrategy.REPLACE)?:::В случаи совпадений старая запись будет заменена новой:::В случаи совпадений старая запись будет заменена новой--База содержит только один желемент и он постоянно перезаписывается--Не записывать элемент если его ещё нет в таблице--Дает ограничение на запись
Room:::Что делает данная аннотация @Insert(onConflict = OnConflictStrategy.IGNORE)?:::В случаи совпадений старая запись не будет заменена новой:::В случаи совпадений старая запись не будет заменена новой--Игнорировать занисение в таблицу--Ограничить таблицу на запись параметром который выставляется заранее--Какие-то записи не сохранять
Room:::Что вернет данный метод \n @Delete \n int delete(List<Employee> employee)?:::Количество удаленных записей:::Количество удаленных записей--ID первой удаленной записи--ID последней удаленной записи--возращает в зависимости от успеха удаления число
Room:::Что делает данная аннотация @Transaction?:::Позволяет выполнять несколько методов в рамках одной транзакции:::Позволяет выполнять несколько методов в рамках одной транзакции--Производит транзакцию между двумя классами--Быстрая и не сложная в применении БД--Происходит транзакция обмена данных между двумя объектами
Room:::Возможна ли такая запись \n @Query("SELECT * FROM employee") \n LiveData<List<Employee>> getAll()?:::Да:::Да--Нет, код вызовет ошибку--Да, но чего-то не хватает...--С LiveData такие операции не возможны
Room:::Что такое Subsets?:::Технология позволяющая получить определенные поля и базы данных:::Технология позволяющая получить определенные поля и базы данных--Подгруппа--Позволяется соединять две таблицы--Такого понятия нет
Room:::Какие типы принимает аннтотация @Relation?:::List или Set:::List или Set--Set или Map--List или миссивы--Map
Room:::Зачем используется данная аннотация @Relation(parentColumn = "id", entityColumn = "department_id", entity = Employee.class)?:::Чтобы вытянуть из класса Employee часть необходимых переменных:::Чтобы вытянуть из класса Employee часть необходимых переменных--Что полностью сзязать две таблиц одна из которых Employer--Удаление из всей таблиц особых переменных--В данной аннтоции ошибка
Room:::Зачем используется сочетание Relation + Transaction?:::Запросы в одной транзакции, чтобы получить корректные данные:::Запросы в одной транзакции, чтобы получить корректные данные--Такой комбинации нет--Для получение двух разных ответов--Что бы отслеживать какая информация поступает
Room:::Что делает аннотация @TypeConverter?:::Для сохранениея в базу полей которые не являются примитивами:::Для сохранениея в базу полей которые не являются примитивами--Для перевода при сохранении в другой тип(Int - Double)--Узнать тип данных в таблице--Переформатирование таблицы
Room:::Что делает данный метод \n @Query("SELECT * FROM employee WHERE birthday = :birthday")  Employee getByDate(@TypeConverters({DateConverter.class}) Date birthday)?:::Преобразует birthday к не видемому для нас примитиву и вернет обьект класса Employee:::Преобразует birthday к не видемому для нас примитиву и вернет обьект класса Employee--Не генерирует исключения при ошибке. просто пропускает--Найдет нужную нам дату--Ничего такой комбинации нет
SQL:::Если вы меняете структуру базы данных...:::необходимо поднимать версию базы данных:::необходимо поднимать версию базы данных--такое не возможно--необходимо дать им специлаьную аннтоацию--Удалить всю базу и создать ее заново
Room:::Зачем нужен объект Migration?:::Сделать миграцию между версиями баз данных:::Сделать миграцию между версиями баз данных--Сделать миграцию в другую базу--Сделаеть миграцию из другой базы--Для получение внешних ключей
Room:::Какой метод нужно вызвать у Room.databaseBuilder().. что бы указать миграцию версий?:::.addMigrations(AppDatabase.MIGRATION_1_2):::.addMigrations(AppDatabase.MIGRATION_1_2)--.putMigrations(AppDatabase.MIGRATION_1_2)--.cutMigrations(AppDatabase.MIGRATION_1_2)--.foundMigrations()
Service:::Когда вызывается метод .onStartCommand?:::Когда сервис запущен методом startService:::Когда сервис запущен методом startService--При любом запуске сервиса--На в сервис поступает информация--При любом обращении к сервису
Service:::Что делает метод stopSelf()?:::Уничтожает сервис изнутри:::Уничтожает сервис изнутри--Преостонавливает сервис--Останавливает все сервисы за раз--Такого метода нет
Service:::Какая роль у переменной startId?:::Счетчик вызовов startService:::Счетчик вызовов startService--Хронит количество запущенных сервисов на телефоне--Такой переменой нет--Имя сервиса
Service:::Что делает метод stopSelf(startId):::Уничтожает сервис под номером startId:::Уничтожает сервис под номером startId--Сервис на делает паузу на startId миллисекунд--Освобождает необходимое число памяти--Такого мотода нет
Service:::В чем разницу между stopSelfResult(startId) и stopSelf(startId?:::stopSelfResult(startId) возвращает boolean если после вызова этой функции сервис был остановлен:::stopSelfResult(startId) возвращает boolean если после вызова этой функции сервис был остановлен--stopSelfResult(startId) возращает результат работы сервиса--stopSelfResult(startId) не уничтожает сервис, а возращает промежуточный результат его работы--stopSelfResult(startId) одно и тоже просто одно использовалось в более раней версии
Service:::Что делает флаг onStartCommand.START_NOT_STICKY?:::Сервис не будет перезапущен после того, как был убит системой:::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId)--Сервис будет перезапущен после того, как был убит системой--Сервис не будет перезапущен после того, как был убит системой--Такого флага нет
Service:::Что делает флаг onStartCommand.START_STICKY?:::Сервис будет перезапущен после того, как был убит системой:::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId)--Сервис будет перезапущен после того, как был убит системой--Сервис не будет перезапущен после того, как был убит системой--Такого флага нет
Service:::Что делает флаг onStartCommand.START_REDELIVER_INTENT?:::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId):::Сервис будет перезапущен после того, как был убит системой. Кроме этого, сервис снова получит все вызовы startService, которые не были завершены методом stopSelf(startId)--Сервис будет перезапущен после того, как был убит системой--Сервис не будет перезапущен после того, как был убит системой--Такого флага нет
Service:::Что делает флаг START_FLAG_REDELIVERY?:::Мы получали такой вызов, но в прошлый раз:::Мы получали такой вызов, но в прошлый раз--Сервис удален системой--Сервис был вызван впервый раз--Ошибка при прикрощении работы сервиса
Service:::Что делает метод PendingIntent.send()?:::Отправляет информацию из сервиса в активити:::Отправляет информацию из сервиса в активити--Просил информацию из активити--Отправляет почту--Нужен для запроса на разрешение использовать сервис в фоновом режиме
Dagger 2:::Для чего нужна аннотация @Provides?:::Указывает, что метод является поставщиком объекта:::Указывает, что метод является поставщиком объекта--Указывает что метод является провайдером--Указывает что переменная является провайдером--Класс является компонентом
Dagger 2:::Для чего нужна аннотация @Component?:::Для генерации класса DaggerAppComponent:::Для генерации класса DaggerAppComponent--Класс для хранения модулей--Класс для вызова модулей--Переменная поиска элементов в Dagger
Service:::Что делает метод sendBroadcast?:::Ищем подходящий BroadcastReceiver для его реализации:::Ищем подходящий BroadcastReceiver для его реализации--Спрашивает существует ли BroadcastReceiver--Удаляет BroadcastReceiver--Делает запрос в класс BroadcastReceiver
Service:::Зачем нужен объект ServiceConnection?:::Для того чтобы знать когда мы подключились к сервису и когда связь с сервисом потеряна:::Для того чтобы знать когда мы подключились к сервису и когда связь с сервисом потеряна--Для подключения к сервису--Для передачи данных между сервисами--Хранит внутри себя информацию о всех сервисах на устройстве
Service:::Когда срабатывает метод onServiceDisconnected?:::При потере связи с сервисом:::При потере связи с сервисом--При перезаписи сервиса--При подключении с сервисом--Сам сервис вызывает при окончании работы
Service:::Что означает флаг BIND_AUTO_CREATE?:::Если сервис, к которому мы пытаемся подключиться, не работает, то он будет запущен:::Если сервис, к которому мы пытаемся подключиться, не работает, то он будет запущен--Запустить сервис--Перезапустить сервис--В случаи ошибки уведомить систему об этом
Service:::При вызове метода unbindService сработает ли метод onServiceDisconnected?:::Нет:::Нет--Конечно сработает, это ведь остановка сервиса--Будет ошибка при таком удалении--Система будет ждать вызова onServiceDisconnected и так, и так
Service:::Какая разница между обычным вызов сервиса и биндингом?:::Биндинг - это синхронная работа с сервисом:::Биндинг - это синхронная работа с сервисом--Биндинг - это асинхронная работа с сервисом--Никакой разницы--Обычный вызов не созращает значение
Service:::Когда срабатывает метод onBind?:::При начале работы с сервисвом:::При начале работы с сервисвом--Биндинг - это асинхронная работа с сервисом--Никакой разницы--Обычный вызов не созращает значение
Service:::Когда срабатывает метод onRebind?:::При повторном подключение к серверу через биндинг:::При повторном подключение к серверу через биндинг--При отключении от сервиса--если сервис ещё не закончил работу, но его пытаются убить--При первом создании сервиса
Service:::Необходимое условме для локального биндинга?:::Сервис и приложение должны выполняться в одном процессе:::Сервис и приложение должны выполняться в одном процессе--Сервис и приложение должны выполняться в разных процессах--Сервис должен быть вызван только один раз--Сервис ещё не должен быть ни кем создан
Service:::Зачем нужен класс IntentService?:::Для выполнения тяжелых операций асинхронна:::Для выполнения тяжелых операций асинхронна--Класс стоящий над Service--Сервис с Intent поумолчанию--Сервис который никогда не умирает
Service:::Что происходит в методе onHandleIntent?:::Обработка данных поступающих в IntentService:::Обработка данных поступающих в IntentService--Обработка данных поступающих в Service--Метод для запуска отдельного потока в любом сервисе--Метод который не умерает даже после завершения работы с сервисом
Service:::Что делает метод startForeground(int id, Notification notification)?:::Сервис не будет удален при нехватке памяти:::Сервис не будет удален при нехватке памяти--Отображение уведомелния в сервисе--Удаление уведомления в сервисе--Перезапуск сервиса
Service:::Что означает данный атрибут android:exported="true"?:::Возможность другим приложениям получить доступ к вашему сервису:::Возможность другим приложениям получить доступ к вашему сервису--Сервис не убиваем--В случаи ошибки перезапустить сервис--Упрощенная работа с сервисом
Java Core:::Что такое неизменяемый класс?:::Это класс, состояние которого не может быть изменено после создания:::Это класс, состояние которого не может быть изменено после создания--Это класс который будет измененм после создания, но только один раз--Класс к которому мы не обращаемя в процессе работы--Класс в котором сет-методы приватные
Java Core:::Что такое JRE?:::Минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений:::Минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений--Комплект разработчика на языке Java--Виртуальная машина Java--Программа для выполнеиня кода на других языках
Java Core:::Что такое Package level access?:::Доступ из одного класса package-a в другой:::Доступ из одного класса package-a в другой--Компонент для серилизации данных--Виртуальная машина Java--Программа для выполнеиня кода на других языках
Java Core:::Одно из отличий абстрактных классов и интерфейсов?:::Абстрактный классы — класс с реализацией метода по умолчанию для подклассов:::Абстрактный классы — класс с реализацией метода по умолчанию для подклассов--Интерфейсы — могут иметь реализацию--Интерфесы используются только для наследования--Интерфейс может наследовать абстрактный класс, но не на аборот
Java Core:::Для чего есть статические блоки?:::Для выполнения кода до вызова конструктора:::Для выполнения кода до вызова конструктора--Компонент для серилизации данных--Для вызова из из другого класса--Блок который выполниться после смерти объекта
Java Core:::Что делает метод wait()?:::Этот метод  метод переводит поток в режим ожидания до момента вызова метода notify():::Этот метод  метод переводит поток в режим ожидания до момента вызова метода notify()--Предварительная остановка потока--Убить поток--Перезапуск потока
Java Core:::Что делает метод notifyAll():::Этот метод переводит все потоки, которые находятся в режиме ожидания в активный режим:::Этот метод переводит все потоки, которые находятся в режиме ожидания в активный режим--Предварительная остановка потока--Убить поток--Перезапуск потока
Layout - Constrain:::Что делает атрибут match_constraints:::View займет пространство, доступное между объектами, к которым он привязан:::View займет пространство, доступное между объектами, к которым он привязан--View займет все место--View не будет видно до вызова спец функции--Элемент по умолчанию
Layout - Constrain:::Чтобы выровнять поц ентру нужно...:::Использовать двухсторонюю привязку:::Использовать двухсторонюю привязку--Указать выровнять по центру--поумолчанию все по центру--Установить специальный атрибут в состояние false
Layout - Constrain:::Зачем нужен атрибут Chain:::Позволит вам равномерно распределить несколько View:::Позволит вам равномерно распределить несколько View--Удалить не нужные View--Дать всем View одинковые характеристики--Не изменять положение при запуске на эмуляторе
Layout - Constrain:::Зачем нужен атрибут spread_inside:::Свободное пространство равномерно распределяется только между View. Крайние View прижимаются к границам родителя:::Свободное пространство равномерно распределяется только между View. Крайние View прижимаются к границам родителя--View займет все место--Дать всем View одинковые характеристики--Не изменять положение при запуске на эмуляторе
Layout - Constrain:::Что делает атрибут app:layout_constraintHorizontal_bias:::Выравнивания по оси:::Выравнивания по оси--View займет все место--Удалит элемент если он выйдет за пределы экрана--Отступ сверху
Layout - Constrain:::Что элемент GuideLines:::Помогают разместить компоненты аккуратно относительно линии:::Помогают разместить компоненты аккуратно относительно линии--Скрывать ненужные компоненты--Копирование компонентов--Отступ сверху
Layout - Constrain:::Что делает атрибут app:layout_constraintDimensionRatio:::Нужно использовать данные пропорции по высоте и ширине:::Нужно использовать данные пропорции по высоте и ширине--Нужно чтобы отобразить только часть данныз--Выравнивание по центру--Отступ снизу
Layout - Constrain:::Что делает атрибут layout_constraintHeight_percent:::Позволяет указать высоту в процентах:::Позволяет указать ширину в процентах--Позволяет указать высоту в процентах--Делает отступ между элементами--Ограничение в создании обьектов
Layout - Constrain:::Что такое Barriers:::Шаблон для нескольких элементов если один элемент них увеличивается, то барьер подстроит размер остальных:::Шаблон для нескольких элементов если один элемент них увеличивается, то барьер подстроит размер остальных--Шаблон для нескольких элементов если один элемент них уменьшится, то барьер подстроит размер остальных--Буфер для копирования компонетов--Отступ вокруг элементов
Layout - Constrain:::Что делает атрибут app:constraint_referenced_ids:::Указывает группу элементов под Barriers:::Указывает группу элементов под Barriers--Указывает группу элементов под Group--Сравнение размеров--Если элемент не будет взелать в экран обрезать его
Layout - Constrain:::Для чего нужен компонент ConstraintSet:::Для анимации разметки:::Для анимации разметки--Показывать только пару элементов--Сравнение размеров--Указывает группу элементов под Barriers
Layout - Constrain:::Для чего нужен компонент Circular:::Помогает настроить два компонента так, чтобы одно находилось на определённом расстоянии и под определённым углом от другого:::Помогает настроить два компонента так, чтобы одно находилось на определённом расстоянии и под определённым углом от другого--Создает круг--Сравнение размеров--Если элемент не будет взелать в экран обрезать его
Layout - Constrain:::Для чего нужен компонент layout_constraintCircle:::Указываем идентификатор компонента, который будет центром окружности:::Указываем идентификатор компонента, который будет центром окружности--Создать круг--Дать элементу круглую форму--Обрезать ImageView
Layout - Constrain:::Для чего нужен компонент Placeholder:::Использовать место на экране в качестве временного заполнителя:::Использовать место на экране в качестве временного заполнителя--Удаление элементов--Указывает группу элементов под Barriers--Дать элементу круглую форму
Layout - Linear:::Для чего нужен компонент android:weightSum:::Позволяет указать сумму весов всех элементов:::Позволяет указать сумму весов всех элементов--Если элемент без веса его не отображать--Сравнение размеров--Если элемент не будет взелать в экран обрезать его
Layout - Linear:::Для чего нужен компонент android:baselineAligned:::Убирает базовую линнию:::Убирает базовую линнию--Смещает базовую линнию--Дает возможность самому задать базовую линнию--Такого атрибута нет
Layout - Linear:::Для чего нужен компонент android:divider:::Позволяющий задать графический разделитель:::Позволяющий задать графический разделитель--Делает разметку свободной--Привязывает элементы друг к другу--Если элемент без веса его не отображать
Layout - Linear:::Для чего нужен компонент android:showDividers:::Указывает где будет находиться разделитель:::Указывает где будет находиться разделитель--Смещает базовую линнию--Позволяющий задать графический разделитель--Позволяет указать сумму весов всех элементов
Layout - Linear:::Какие аргументы принимает данный метод newLinearLayout.LayoutParams:::Размеры LinearLayout:::Размеры LinearLayout--Где будет отображен LinearLayout--Задает базовую линнию--Добавляет параметры
Layout - Frame:::Для чего нужен компонент android:measureAllChildren:::Для корректного отображения скрытого элемента:::Для корректного отображения скрытого элемента--Задает параметры дочерним элементам--Позволяет проверить сумму весов--Привязывает элементы друг к другу
Layout - Relative:::Для чего нужен компонент android:layout_alignParentLeft:::Выравнивание относительно левого края родителя:::Выравнивание относительно левого края родителя--Выравнивание относительно правого края родителя--Отступ слева--Отступ справа
Layout - Relative:::Для чего нужен компонент android:layout_below:::Размещается под указанным компонентом:::Размещается под указанным компонентом--Размещается над указанным компонентом--Отступ сверху--Отступ снизу
Layout - Relative:::Для чего нужен компонент android:layout_alignRight:::Выравнивается по правому краю указанного компонента:::Выравнивается по правому краю указанного компонента--Левый край компонент размещается справа от указанного компонента--Выравнивание относительно правого края родителя--Элемент всегда справа
Layout - Relative:::Для чего нужен компонент android:layout_toRightOf:::Выравнивание относительно левого края родителя:::Выравнивание относительно левого края родителя--Выравнивается по правому краю указанного компонента--Выравнивание относительно правого края родителя--Элемент всегда справа
Layout - Relative:::Что делает метод addRule():::Добавляет дополнительные правила для позиционирования элемента:::Добавляет дополнительные правила для позиционирования элемента--Делает отступ--Возращает поведение элемента--Дает права на свободное расположение
Retrofit 2:::Зачем нужна аннотация @Path:::Переменная для замещения конечной точки, например, username подставится в {username} в адресе конечной точки:::Переменная для замещения конечной точки, например, username подставится в {username} в адресе конечной точки--Задаёт имя ключа запроса со значением параметра--Возращает поведение элемента--Указывает, что метод является поставщиком объекта
Retrofit 2:::Зачем нужна аннотация @Query:::Задаёт имя ключа запроса со значением параметра:::Задаёт имя ключа запроса со значением параметра--Переменная для замещения конечной точки, например, username подставится в {username} в адресе конечной точки--Указывает, что метод является поставщиком объекта
Retrofit 2:::Зачем нужна аннотация @Body:::Используется в POST-вызовах (из Java-объекта в JSON-строку):::Используется в POST-вызовах (из Java-объекта в JSON-строку)--Задаёт имя ключа запроса со значением параметра--Возращает поведение элемента--Переменная для замещения конечной точки, например, username подставится в {username} в адресе конечной точки
Retrofit 2:::Зачем нужна аннотация @Headers:::Задаёт все заголовки вместе:::Задаёт все заголовки вместе--Задаёт имя ключа запроса со значением параметра--Для поддержки динамических адресов--Указывает, что метод является поставщиком объекта
Retrofit 2:::Зачем нужна аннотация @Multipart:::Используется при загрузке файлов или изображений:::Используется при загрузке файлов или изображений--Задаёт имя ключа запроса со значением параметра--GET-запрос для базового адреса. Также можно указать параметры в скобках--Задаёт все заголовки вместе
Retrofit 2:::Зачем нужна аннотация @FieldMap:::Используется при использовании пары "имя/значение" в POST-запросах:::Используется при использовании пары "имя/значение" в POST-запросах--Задаёт имя ключа запроса со значением параметра--GET-запрос для базового адреса. Также можно указать параметры в скобках--Используется при загрузке файлов или изображений
Retrofit 2:::Зачем нужна аннотация @Url:::Для поддержки динамических адресов:::Для поддержки динамических адресов--Используется при использовании пары "имя/значение" в POST-запросах--Задаёт все заголовки вместе--Используется при загрузке файлов или изображений
Retrofit 2:::Зачем используется метож Call.cancel():::Для отмены запроса:::Для отмены запроса--Что бы закрыть поток данных--Выход из интрефейса--Закрыть приложение
Dagger 2:::Зачем нужна аннотация @Inject:::Пометку для зависимостей, которые должны быть предоставлены:::Пометку для зависимостей, которые должны быть предоставлены--Задаёт имя ключа запроса со значением параметра--Определяет метод для наследования--Используется при загрузке файлов или изображений
Dagger 2:::Для чего нужен Constructor Injection:::Для использования с конструктором класса:::Для использования с конструктором класса--Для использования с методом класса--Удаление констуртора класса--Удаление метода класса
Dagger 2:::Зачем нужен @Module(includes = ....):::Для связки модулей:::Для связки модулей--Для отображения в других классах--Перформатирование модуля--Удаление метода класса
Dagger 2:::Зачем нужна аннотация @Scope:::Заставляет зависимость работать как singleton:::Заставляет зависимость работать как singleton--Для отображения в других классах--Перформатирование модуля--Для использования с конструктором класса
Dagger 2:::Зачем нужна аннотация @Retention:::Для обозначения точки отклонения использования аннотации:::Для обозначения точки отклонения использования аннотации--Для использования с конструктором класса--Перформатирование модуля--Заставляет зависимость работать как singleton
Dagger 2:::Что сделает данная аннотация @Retention(RetentionPolicy.CLASS):::Аннотация будет доступна во время компиляции, но не во время работы программы:::Аннотация будет доступна во время компиляции, но не во время работы программы--Для отображения в других классах--Аннотация будет доступна и во время выполнения программы--Аннотация будет доступна только в исходном коде и будет отброшена во время компиляции
Dagger 2:::Что сделает данная аннотация @Retention(RetentionPolicy.SOURCE):::Аннотация будет доступна только в исходном коде и будет отброшена во время компиляции:::Аннотация будет доступна во время компиляции, но не во время работы программы--Для отображения в других классах--Аннотация будет доступна и во время выполнения программы--Аннотация будет доступна только в исходном коде и будет отброшена во время компиляции
Dagger 2:::Что сделает данная аннотация @Retention(RetentionPolicy.RUNTIME):::Аннотация будет доступна и во время выполнения программы:::Аннотация будет доступна и во время выполнения программы--Для отображения в других классах--Аннотация будет доступна во время компиляции, но не во время работы программы--Аннотация будет доступна только в исходном коде и будет отброшена во время компиляции
Dagger 2:::Для чего нужна аннотация @Named:::Аннотация поможет нам различить контекст:::Аннотация поможет нам различить контекст--Обработка ошибок--Пересоздание модуля--Второе имя для поиска переменных
Dagger 2:::Зачем нужен @Component(dependencies = ....):::Говорит куда обращаться за дополнительными зависимостями:::Говорит куда обращаться за дополнительными зависимостями--Для отображения в других классах--Удаление специального обьекта--Создание синголтона
Coroutines:::Для пометка функции suspend?:::Для обозначения прерываемой функции:::Для обозначения прерываемой функции--Для отображения в других классах--Аннотация будет доступна во время компиляции, но не во время работы программы--Аннотация будет доступна только в исходном коде и будет отброшена во время компиляции
Coroutines:::Что такое State machine:::Объект создаваемый компилятором. Он имеет метки, которые определяют этапы выполнения кода:::Объект создаваемый компилятором. Он имеет метки, которые определяют этапы выполнения кода--Объект. Он имеет метки, которые определяют что возвратит система--Объект создаваемый компилятором. Он имеет метки, что выполнять код ассинхронна--Специальный объект
Coroutines:::Что сделает вызов SuspendCoroutine:::Остановит текущую coroutine, для выполнения асинхронной операции:::Остановит текущую coroutine, для выполнения асинхронной операции--Объект создаваемый компилятором. Он имеет метки, которые определяют этапы выполнения кода--Объект создаваемый компилятором. Он имеет метки, что выполнять код ассинхронна--Для обозначения прерываемой функции
Coroutines:::Что сделает вызов launch:::Это билдер coroutine, который мгновенно возвращает вызов:::Это билдер coroutine, который мгновенно возвращает вызов--Остановит текущую coroutine, для выполнения асинхронной операции--Объект создаваемый компилятором. Он имеет метки, что выполнять код ассинхронна--Возвращает здачение из потока
Coroutines:::Что сделает вызов async:::Выполнять нескоько операций одновременно:::Выполнять нескоько операций одновременно--Это билдер coroutine, который мгновенно возвращает вызов--Объект создаваемый компилятором. Он имеет метки, что выполнять код ассинхронна--Для обозначения прерываемой функции
Coroutines:::Что сделает вызов job.cancel:::Остановку coroutine:::Остановку coroutine--Объект создаваемый компилятором. Он имеет метки, которые определяют этапы выполнения кода--Объект создаваемый компилятором. Должен быть удален--Это билдер coroutine, который мгновенно возвращает вызов
Coroutines:::Что сделает вызов job.join():::Ожидает завершения выполнения:::Ожидает завершения выполнения--Это билдер coroutine, который мгновенно возвращает вызов--Остановку coroutine--Для обозначения прерываемой функции
Coroutines:::Что сделает вызов runBlocking<Unit>:::Программа не завершится пока не пройдет этот блок:::Программа не завершится пока не пройдет этот блок--Остановит текущую coroutine, для выполнения асинхронной операции--Остановку coroutine--Выполнять нескоько операций одновременно
Coroutines:::Что сделает вызов coroutineScope:::Приостанавливает работу, освобождая базовый поток для других применений:::Приостанавливает работу, освобождая базовый поток для других применений--Остановит текущую coroutine, для выполнения асинхронной операции--Остановку coroutine--Программа не завершится пока не пройдет этот блок
Coroutines:::Что сделает вызов repeat:::Повторение определленого блока указаное количество раз:::Повторение определленого блока указаное количество раз--Остановит текущую coroutine, для выполнения асинхронной операции--Выполнять нескоько операций одновременно--Это билдер coroutine, который мгновенно возвращает вызов
Coroutines:::Что сделает вызов withTimeout:::Завершает выполнение корутины по окончанию указаного времени:::Завершает выполнение корутины по окончанию указаного времени--Приостанавливает работу, освобождая базовый поток для других применений--Выполнять нескоько операций одновременно--Программа не завершится пока не пройдет этот блок
Coroutines:::Что сделает вызов measureTimeMillis:::Вызывает код последовательно:::Вызывает код последовательно--Завершает выполнение корутины по окончанию указаного времени--Остановку coroutine--Программа не завершится пока не пройдет этот блок
Coroutines:::Что сделает вызов CoroutineStart.LAZY в async в параменте start:::Делает запуск корутины ленивым:::Делает запуск корутины ленивым--Вызывает код последовательно--Остановит текущую coroutine, для выполнения асинхронной операции--Это билдер coroutine, который мгновенно возвращает вызов
Coroutines:::Что сделает вызов coroutineScope:::Код выполняется ассинхронна, но в случаи ошибки все потоки останавливаются:::Код выполняется ассинхронна, но в случаи ошибки все потоки останавливаются--Делает запуск корутины ленивым--Выполнять нескоько операций одновременно--Выполнять нескоько операций одновременно
Coroutines:::Что сделает вызов launch(Dispatchers.Unconfined):::Будет работать с основным потоком:::Будет работать с основным потоком--Код выполняется ассинхронна, но в случаи ошибки все потоки останавливаются--Выполнять нескоько операций одновременно--Делает запуск корутины ленивым--Выполнять нескоько операций одновременно
